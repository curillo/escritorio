export enum MergeResultKind {
  Success = 'Success',
  Conflicts = 'Conflicts',
}

interface IBlobResult {
  readonly mode: string
  readonly sha: string
  readonly path: string
}

interface IMergeEntry {
  readonly context: string
  readonly base?: IBlobResult
  readonly result?: IBlobResult
  readonly our?: IBlobResult
  readonly their?: IBlobResult
  readonly diff: string
}

export interface IMergeSuccess {
  readonly kind: MergeResultKind.Success
  readonly entries: ReadonlyArray<IMergeEntry>
}

export interface IMergeError {
  readonly kind: MergeResultKind.Conflicts
  readonly conflictedFiles: number
}

function updateCurrentMergeEntry(
  entry: IMergeEntry | undefined,
  context: string,
  blobSource: {
    readonly type: string
    readonly path: string
    readonly sha: string
    readonly mode: string
  }
): IMergeEntry {
  let currentMergeEntry = entry || {
    context,
    diff: '',
  }

  const blob = {
    sha: blobSource.sha,
    mode: blobSource.mode,
    path: blobSource.path,
  }

  switch (blobSource.type) {
    case 'base':
      return {
        ...currentMergeEntry,
        base: blob,
      }
    case 'result':
      return {
        ...currentMergeEntry,
        result: blob,
      }
    case 'our':
      return {
        ...currentMergeEntry,
        our: blob,
      }

    case 'their':
      return {
        ...currentMergeEntry,
        our: blob,
      }

    case 'base':
      return {
        ...currentMergeEntry,
        our: blob,
      }
    default:
      return currentMergeEntry
  }
}

export type MergeResult = IMergeSuccess | IMergeError

const contextHeaderRe = /^(merged|added in remote|changed in both)$/

// examples:
//  result 100644 2f9cf6d58beb7abf74b241c52c4deed1155c7e98 app/src/lib/app-state.ts
//  our    100644 5382e869682845ac92aee17c4ebcb0609749ab88 app/src/lib/app-state.ts
const blobEntryRe = /^\s{2}(result|our|their|base)\s+(\d{6})\s([0-9a-f]{40})\s(.+)$/

export function parseMergeResult(text: string): MergeResult {
  const entries = new Array<IMergeEntry>()

  const lines = text.split('\n')

  let context: string | undefined
  let currentMergeEntry: IMergeEntry | undefined

  for (const line of lines) {
    const headerMatch = contextHeaderRe.exec(line)
    if (headerMatch != null) {
      context = headerMatch[1]

      // push the previous entry, if defined, into the array
      if (currentMergeEntry != null) {
        entries.push(currentMergeEntry)
        currentMergeEntry = undefined
      }

      continue
    }

    // the next lines are a number of merge result entries
    // pointing to blobs representing the source blob
    // and the resulting blob generated by the merge
    const blobMatch = blobEntryRe.exec(line)
    if (blobMatch != null) {
      const type = blobMatch[1]
      const mode = blobMatch[2]
      const sha = blobMatch[3]
      const path = blobMatch[4]

      const blob = {
        type,
        mode,
        sha,
        path,
      }

      if (context == null) {
        console.log(
          `we're trying to parse path ${path} but there is no context`
        )
        continue
      }

      switch (type) {
        case 'base':
        case 'result':
        case 'our':
        case 'their':
          currentMergeEntry = updateCurrentMergeEntry(
            currentMergeEntry,
            context,
            blob
          )
          break

        default:
          console.log(
            `invalid state - unexpected entry ${type} found when parsing rows`
          )
      }
      continue
    }

    if (currentMergeEntry == null) {
      console.log(
        `invalid state - trying to append the diff to a merge entry that isn't defined. line: '${line}'`
      )
    } else {
      const currentDiff = currentMergeEntry.diff
      const newDiff = currentDiff + line + '\n'
      currentMergeEntry = {
        ...currentMergeEntry,
        diff: newDiff,
      }
    }
  }

  // ensure the last entry is pushed onto the array

  if (currentMergeEntry != null) {
    entries.push(currentMergeEntry)
    currentMergeEntry = undefined
  }

  const entriesWithConflicts = entries.filter(
    e => e.diff.indexOf('<<<<<<<') > 0
  )

  if (entriesWithConflicts.length > 0) {
    return {
      kind: MergeResultKind.Conflicts,
      conflictedFiles: entriesWithConflicts.length,
    }
  } else {
    return { kind: MergeResultKind.Success, entries }
  }
}

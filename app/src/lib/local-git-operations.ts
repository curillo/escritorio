import { WorkingDirectoryStatus, WorkingDirectoryFileChange, FileChange, FileStatus } from '../models/status'
import Repository from '../models/repository'

import { GitProcess, GitError, GitErrorCode } from './git-process'

/** The encapsulation of the result from 'git status' */
export class StatusResult {
  /** true if the repository exists at the given location */
  public readonly exists: boolean

  /** the absolute path to the repository's working directory */
  public readonly workingDirectory: WorkingDirectoryStatus

  /** factory method when 'git status' is unsuccessful */
  public static NotFound(): StatusResult {
    return new StatusResult(false, new WorkingDirectoryStatus(new Array<WorkingDirectoryFileChange>(), true))
  }

  /** factory method for a successful 'git status' result  */
  public static FromStatus(status: WorkingDirectoryStatus): StatusResult {
    return new StatusResult(true, status)
  }

  public constructor(exists: boolean, workingDirectory: WorkingDirectoryStatus) {
    this.exists = exists
    this.workingDirectory = workingDirectory
  }
}

/** A git commit. */
export class Commit {
  /** The commit's SHA. */
  public readonly sha: string

  /** The first line of the commit message. */
  public readonly summary: string

  /** The commit message without the first line and CR. */
  public readonly body: string
  public readonly authorName: string
  public readonly authorEmail: string
  public readonly authorDate: Date

  public constructor(sha: string, summary: string, body: string, authorName: string, authorEmail: string, authorDate: Date) {
    this.sha = sha
    this.summary = summary
    this.body = body
    this.authorName = authorName
    this.authorEmail = authorEmail
    this.authorDate = authorDate
  }
}

/** indicate what a line in the diff represents */
export enum DiffLineType {
  Context, Add, Delete
}

/** track details related to each line in the diff */
export class DiffLine {
  public readonly text: string
  public readonly type: DiffLineType
  public readonly oldLineNumber: number | null
  public readonly newLineNumber: number | null

  public constructor(text: string, type: DiffLineType, oldLineNumber: number | null, newLineNuber: number | null) {
    this.text = text
    this.type = type
    this.oldLineNumber = oldLineNumber
    this.newLineNumber = newLineNuber
  }
}

/** details about the start and end of a section of a diff */
export class DiffSectionRange {
  public readonly oldStartLine: number
  public readonly oldEndLine: number
  public readonly newStartLine: number
  public readonly newEndLine: number

  public constructor(oldStartLine: number, oldEndLine: number, newStartLine: number, newEndLine: number) {
    this.oldStartLine = oldStartLine
    this.oldEndLine = oldEndLine
    this.newStartLine = newStartLine
    this.newEndLine = newEndLine
  }
}

/** each diff is made up of a number of sections */
export class DiffSection {
  public readonly range: DiffSectionRange
  public readonly lines: DiffLine[]

  /** infer the type of a diff line based on the prefix */
  private static mapToDiffLineType(text: string) {
    if (text.startsWith('-')) {
        return DiffLineType.Delete
    } else if (text.startsWith('+')) {
        return DiffLineType.Add
    } else {
        return DiffLineType.Context
    }
  }

  public constructor(range: DiffSectionRange, lines: string[]) {
    this.range = range

    let rollingDiffBeforeCounter = range.oldStartLine
    let rollingDiffAfterCounter = range.newStartLine

    const diffLines = lines.map(text => {
      // the unified patch format considers these lines to be headers
      // -> exclude them from the line counts
      if (text.startsWith('@@')) {
        return new DiffLine(text, DiffLineType.Context, null, null)
      }

      const type = DiffSection.mapToDiffLineType(text)

      if (type === DiffLineType.Delete) {
        rollingDiffBeforeCounter = rollingDiffBeforeCounter + 1

        return new DiffLine(text, type, rollingDiffBeforeCounter, null)
      } else if (type === DiffLineType.Add) {
        rollingDiffAfterCounter = rollingDiffAfterCounter + 1

        return new DiffLine(text, type, null, rollingDiffAfterCounter)
      } else {
        rollingDiffBeforeCounter = rollingDiffBeforeCounter + 1
        rollingDiffAfterCounter = rollingDiffAfterCounter + 1

        return new DiffLine(text, type, rollingDiffBeforeCounter, rollingDiffAfterCounter)
      }
    })

    this.lines = diffLines
  }
}

/** the contents of a diff generated by Git */
export class Diff {
   public readonly sections: DiffSection[]
   public readonly lines: DiffLine[]

   public constructor(sections: DiffSection[]) {
     this.sections = sections

     // flatten the contents of each diff section
     // so it can be drawn  easily in a virtualized list
     //
     // TODO: may not be necessary in the future
     const lines: DiffLine[] = []
     sections.forEach(s => {
       s.lines.forEach(l => lines.push(l))
     })

     this.lines = lines
   }
}

/**
 * Interactions with a local Git repository
 */
export class LocalGitOperations {

  /**
   * map the raw status text from Git to an app-friendly value
   * shamelessly borrowed from GitHub Desktop (Windows)
   */
  private static mapStatus(rawStatus: string): FileStatus {

    const status = rawStatus.trim()

    if (status === 'M') { return FileStatus.Modified }      // modified
    if (status === 'A') { return FileStatus.New }           // added
    if (status === 'D') { return FileStatus.Deleted }       // deleted
    if (status === 'R') { return FileStatus.Renamed }       // renamed
    if (status === 'RM') { return FileStatus.Renamed }      // renamed in index, modified in working directory
    if (status === 'RD') { return FileStatus.Conflicted }   // renamed in index, deleted in working directory
    if (status === 'DD') { return FileStatus.Conflicted }   // Unmerged, both deleted
    if (status === 'AU') { return FileStatus.Conflicted }   // Unmerged, added by us
    if (status === 'UD') { return FileStatus.Conflicted }   // Unmerged, deleted by them
    if (status === 'UA') { return FileStatus.Conflicted }   // Unmerged, added by them
    if (status === 'DU') { return FileStatus.Conflicted }   // Unmerged, deleted by us
    if (status === 'AA') { return FileStatus.Conflicted }   // Unmerged, added by both
    if (status === 'UU') { return FileStatus.Conflicted }   // Unmerged, both modified
    if (status === '??') { return FileStatus.New }          // untracked

    return FileStatus.Modified
  }

  /**
   *  Retrieve the status for a given repository,
   *  and fail gracefully if the location is not a Git repository
   */
  public static getStatus(repository: Repository): Promise<StatusResult> {
    return GitProcess.execWithOutput([ 'status', '--untracked-files=all', '--porcelain' ], repository.path)
        .then(output => {
            const lines = output.split('\n')

            const regex = /([\? \w]{2}) (.*)/
            const regexGroups = { mode: 1, path: 2 }

            const files = new Array<WorkingDirectoryFileChange>()

            for (const index in lines) {
              const line = lines[index]
              const result = regex.exec(line)

              if (result) {
                const modeText = result[regexGroups.mode]
                const path = result[regexGroups.path]

                const status = this.mapStatus(modeText)
                files.push(new WorkingDirectoryFileChange(path, status, true))
              }
            }

            return StatusResult.FromStatus(new WorkingDirectoryStatus(files, true))
        })
        .catch(error => {
          if (error) {
            const gitError = error as GitError
            if (gitError) {
              const code = gitError.errorCode
              if (code === GitErrorCode.NotFound) {
                return StatusResult.NotFound()
              }
              throw new Error('unable to resolve HEAD, got error code: ' + code)
            }
          }

          throw new Error('unable to resolve status, got unknown error: ' + error)
        })
  }

  private static async resolveHEAD(repository: Repository): Promise<boolean> {
    return GitProcess.execWithOutput([ 'show', 'HEAD' ], repository.path)
      .then(output => {
        return Promise.resolve(true)
      })
      .catch(error => {
        if (error) {

          const gitError = error as GitError
          if (gitError) {
              const code = gitError.errorCode
              if (code === GitErrorCode.NotFound) {
                return Promise.resolve(false)
              }
              throw new Error('unable to resolve HEAD, got error code: ' + code)
            }
         }

        throw new Error('unable to resolve HEAD, got unknown error: ' + error)
      })
  }

  public static createCommit(repository: Repository, title: string, files: ReadonlyArray<WorkingDirectoryFileChange>) {
    return this.resolveHEAD(repository)
      .then(result => {
        let resetArgs = [ 'reset' ]
        if (result) {
          resetArgs = resetArgs.concat([ 'HEAD', '--mixed' ])
        }

        return resetArgs
      })
      .then(resetArgs => {
        // reset the index
        return GitProcess.exec(resetArgs, repository.path)
          .then(_ => {
            // TODO: staging hunks needs to be done in here as well
            const addFiles = files.map((file, index, array) => {

              let addFileArgs: string[] = []

              if (file.status === FileStatus.New) {
                addFileArgs = [ 'add', file.path ]
              } else {
                addFileArgs = [ 'add', '-u', file.path ]
              }

              return GitProcess.exec(addFileArgs, repository.path)
            })

            // TODO: pipe standard input into this command
            return Promise.all(addFiles)
              .then(() => {
                return GitProcess.exec([ 'commit', '-m',  title ] , repository.path)
              })
          })
        })
      .catch(error => {
          console.error('createCommit failed: ' + error)
      })
  }

  /**
    * Render the diff for a file within the repository
    *
    * A specific commit related to the file may be provided, otherwise the
    * working directory state will be used.
    */
  public static getDiff(repository: Repository, file: FileChange, commit: Commit | null): Promise<Diff> {

    let args: string[]

    if (commit) {
      args = [ 'show', commit.sha, '--patch-with-raw', '-z', '--', file.path ]
    } else if (file.status === FileStatus.New) {
      args = [ 'diff', '--no-index', '--patch-with-raw', '-z', '--', '/dev/null', file.path ]
    } else {
      args = [ 'diff', 'HEAD', '--patch-with-raw', '-z', '--', file.path ]
    }

    return GitProcess.execWithOutput(args, repository.path)
      .then(result => {
        const lines = result.split('\0')

        const sectionRegex = /^@@ -(\d+)(,+(\d+))? \+(\d+)(,(\d+))? @@ ?(.*)$/m
        const regexGroups = { oldFileStart: 1, oldFileEnd: 3, newFileStart: 4, newFileEnd: 6 }

        const diffText = lines[lines.length - 1]

        const diffSections = new Array<DiffSection>()

        // track the remaining text in the raw diff to parse
        let diffTextBuffer = diffText
        // each diff section starts with these two characters
        let sectionPrefixIndex = diffTextBuffer.indexOf('@@')
        // continue to iterate while these sections exist
        let prefixFound = sectionPrefixIndex > -1

        while (prefixFound) {

          // trim any preceding text
          diffTextBuffer = diffTextBuffer.substr(sectionPrefixIndex)

          // extract the diff section numbers
          const match = sectionRegex.exec(diffTextBuffer)

          let oldStartLine: number = -1
          let oldEndLine: number = -1
          let newStartLine: number = -1
          let newEndLine: number = -1

          if (match) {
            const first = match[regexGroups.oldFileStart]
            oldStartLine = parseInt(first, 10)
            const second = match[regexGroups.oldFileEnd]
            oldEndLine = parseInt(second, 10)
            const third = match[regexGroups.newFileStart]
            newStartLine = parseInt(third, 10)
            const fourth = match[regexGroups.newFileEnd]
            newEndLine = parseInt(fourth, 10)
          }

          const range = new DiffSectionRange(oldStartLine, oldEndLine, newStartLine, newEndLine)

          // re-evaluate whether other sections exist to parse
          const endOfThisLine = diffTextBuffer.indexOf('\n')
          sectionPrefixIndex = diffTextBuffer.indexOf('@@', endOfThisLine + 1)
          prefixFound = sectionPrefixIndex > -1

          // add new section based on the remaining text in the raw diff
          if (prefixFound) {
            const diffBody = diffTextBuffer.substr(0, sectionPrefixIndex)
            diffSections.push(new DiffSection(range, diffBody.split('\n')))
          } else {
            const diffBody = diffTextBuffer
            diffSections.push(new DiffSection(range, diffBody.split('\n')))
          }
        }

        return Promise.resolve(new Diff(diffSections))
      })
  }

  /** Get the repository's history. */
  public static async getHistory(repository: Repository): Promise<ReadonlyArray<Commit>> {
    const batchCount = 100
    const delimiter = '1F'
    const delimeterString = String.fromCharCode(parseInt(delimiter, 16))
    const prettyFormat = [
      '%H', // SHA
      '%s', // summary
      '%b', // body
      '%an', // author name
      '%ae', // author email
      '%aI', // author date, ISO-8601
    ].join(`%x${delimiter}`)
    const out = await GitProcess.execWithOutput([ 'log', `--max-count=${batchCount}`, `--pretty=${prettyFormat}`, '-z', '--no-color' ], repository.path)
    const lines = out.split('\0')
    // Remove the trailing empty line
    lines.splice(-1, 1)

    const commits = lines.map(line => {
      const pieces = line.split(delimeterString)
      const sha = pieces[0]
      const summary = pieces[1]
      const body = pieces[2]
      const committerName = pieces[3]
      const committerEmail = pieces[4]
      const parsedDate = Date.parse(pieces[5])
      const committerDate = new Date(parsedDate)
      return new Commit(sha, summary, body, committerName, committerEmail, committerDate)
    })

    return Promise.resolve(commits)
  }

  /** Get the files that were changed in the given commit. */
  public static async getChangedFiles(repository: Repository, sha: string): Promise<ReadonlyArray<FileChange>> {
    const out = await GitProcess.execWithOutput([ 'show', sha, '--name-status', '--format=format:', '-z' ], repository.path)
    const lines = out.split('\0')
    // Remove the trailing empty line
    lines.splice(-1, 1)

    const files: FileChange[] = []
    for (let i = 0; i < lines.length; i++) {
      const statusText = lines[i]
      const status = this.mapStatus(statusText)
      const name = lines[++i]
      files.push(new FileChange(name, status))
    }

    return files
  }

  /** Look up a config value by name in the repository. */
  public static async getConfigValue(repository: Repository, name: string): Promise<string | null> {
    let output: string | null = null
    try {
      output = await GitProcess.execWithOutput([ 'config', '-z', name ], repository.path)
    } catch (e) {
      // Git exits with 1 if the value isn't found. That's ok, but we'd rather
      // just treat it as null.
      if (e.code !== 1) {
        throw e
      }
    }

    if (!output) { return null }

    const pieces = output.split('\0')
    return pieces[0]
  }

  /** Pull from the remote to the branch. */
  public static pull(repository: Repository, remote: string, branch: string): Promise<void> {
    return GitProcess.exec([ 'pull', remote, branch ], repository.path)
  }

  /** Push from the remote to the branch, optionally setting the upstream. */
  public static push(repository: Repository, remote: string, branch: string, setUpstream: boolean): Promise<void> {
    const args = [ 'push', remote, branch ]
    if (setUpstream) {
      args.push('--set-upstream')
    }

    return GitProcess.exec(args, repository.path)
  }

  /** Get the remote names. */
  private static async getRemotes(repository: Repository): Promise<ReadonlyArray<string>> {
    const lines = await GitProcess.execWithOutput([ 'remote' ], repository.path)
    return lines.split('\n')
  }

  /** Get the name of the default remote. */
  public static async getDefaultRemote(repository: Repository): Promise<string | null> {
    const remotes = await LocalGitOperations.getRemotes(repository)
    if (remotes.length === 0) {
      return null
    }

    const index = remotes.indexOf('origin')
    if (index > -1) {
      return remotes[index]
    } else {
      return remotes[0]
    }
  }

  /** Get the name of the tracking branch for the current branch. */
  public static async getTrackingBranch(repository: Repository): Promise<string | null> {
    try {
      const name = await GitProcess.execWithOutput([ 'rev-parse', '--abbrev-ref', '--symbolic-full-name', '@{u}' ], repository.path)
      return name.trim()
    } catch (e) {
      // Git exits with 1 if there's no upstream. We should do more specific
      // error parsing than this, but for now it'll do.
      if (e.code !== 1) {
        throw e
      }
      return null
    }
  }

  /** Get the name of the current branch. */
  public static async getBranch(repository: Repository): Promise<string | null> {
    try {
      const name = await GitProcess.execWithOutput([ 'rev-parse', '--abbrev-ref', 'HEAD' ], repository.path)
      return name.trim()
    } catch (e) {
      // Git exits with 1 if there's the branch is unborn. We should do more
      // specific error parsing than this, but for now it'll do.
      if (e.code !== 1) {
        throw e
      }
      return null
    }
  }
}
